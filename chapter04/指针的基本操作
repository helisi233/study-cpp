&(取地址)与*(间接引用)操作符
    char ch = 'a';
    char *cP = &ch;

    表达式      右值                           左值  左值必须是一块内存空间 右值必须是一个值
    &ch        合法                           非法
    &cP        合法                           非法
    *cP        指向一个变量的指针               取出指向变量的值
               可以修改指向变量的值

    *cP+1      取出指向变量的值                 非法
               然后对这个值+1

    *(cP+1)    当前内存位置向下偏移一个空间       当前内存位置向下偏移一个空间
               可以取出新空间的值                指向新空间
               可能存在访问不应该访问空间的可能    可以向新空间存储值

++与--操作符
    char* cp2 = ++cp;
        cp先加1 在对cp2赋值
    char* cp3 = cp++;
        先对cp3赋值 cp在加1
    char* cp4 = --cp;
        cp先减1 再对cp4赋值
    char* cp5 = cp--;
        先对cp5赋值 cp再减1

    ++cp
        右值 cp是一个指针 对cp向下移动一个位置(表示一个地址) 对其他指针赋值
        左值 非法
    cp++
        右值 cp是一个指针 先对其他指针赋值 再将cp向下移动一个位置 对其他指针赋值
        左值 非法
    *++cp
        ++的优先级大于* 相当于*(++cp)
        右值 cp是一个指针 将cp向下移动一个位置 对当前位置解引用 赋值给其他变量
        左值 cp是一个指针 将cp向下移动一个位置 对当前位置解引用 可以被其他变量赋值
    *cp++
        ++的优先级大于* 相当于*(cp++)
        右值 cp是一个指针 对当前位置解引用 赋值给其他变量 再将cp向下移动一个位置
        左值 cp是一个指针 对当前位置解引用 可以被其他变量赋值

关于++++,----等运算符
    编译器程序分解成符号的方法是 一个字符一个字符的读入 如果该字符可能组成一个符号
    那么读入下一个字符 一直到读入的字符不在能组成一个有意义的符号 这个过程称为贪心法
    int a = 1,b = 2,c,d;
    c = a+++b; 相当于a++ +b
    d = a++++b; ERROR 相当于a++ ++b没有意义 如果是a+++++b ==> ((a++) + (++b)) 就合法了

    ++*++cp
        相当于(++(*(++cp)))
        右值 cp指针先向下移动一个位置 解引用 对得到的这个值加1 赋值给其他变量
        左值 非法

















